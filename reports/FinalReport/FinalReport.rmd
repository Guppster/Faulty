---
output: 
  pdf_document:
    toc: false
    number_sections: false
    keep_tex: true
    fig_caption: true
    latex_engine: pdflatex
    template: "../templates/gsingh-research.tex"

title: "Faulty: Fault Localization as a Service"
school-name: "University of Western Ontario"
department: "Department of Computer Science"
major-heading: "CS4470Y: Software Maintenance and Configuration"
minor-heading: "Final Project Report"

instructor: 
- firstname: "Nazim"
  lastname: "Madhavji"

supervisor: 
 - firstname: "Kostas" 
   lastname: "Kontogiannis"

author:
- firstname: "Gurpreet"
  lastname: "Singh"
- firstname: "Paul"
  lastname: "Bartlett"

logo: "../images/uwo.jpg"

abstract-bold: Lorem ipsum sodales, accumsan neque eu, placerat purus. Interdum
et malesuada fames ac ante ipsum primis in faucibus. Nulla id varius metus, id
vestibulum purus. Nullam malesuada urna purus, quis euismod velit tristique et.
Fusce auctor laoreet arcu ac maximus. Duis ultricies malesuada dui id pharetra.
Donec tempus semper enim, in interdum ante pharetra sed. Vivamus vel accumsan
metus. Vivamus eu enim est. Duis ac dolor a quam lacinia interdum in ut sem. Ut
ipsum orci, dignissim vel ante eget, blandit sollicitudin dolor.

abstract:  Sed eu orci dolor sit amet, consectetur adipiscing elit. Duis
dapibus nisl vitae tempor placerat. Duis feugiat odio vitae quam pellentesque,
ac semper ex sagittis. Nunc id egestas tortor. Morbi nibh tortor, suscipit vel
libero quis, placerat molestie nulla. Nullam pellentesque ex ac viverra
lobortis. Donec hendrerit nibh nisi, a bibendum urna efficitur ut. Cras
venenatis sem magna, vel dignissim augue convallis a. Proin sapien justo,
viverra ac enim sit amet, cursus aliquet tellus. Nulla at lacus magna. Nullam
sit amet dui convallis, interdum felis eu, viverra ligula. Pellentesque sed
mollis nibh, at ultricies nisi.Quisque id velit suscipit ipsum auctor egestas
egestas sit amet dui. Curabitur at sem nunc. Nunc non ultrices ex, et egestas
odio.  

date: "`r format(Sys.time(), '%B %d, %Y')`"
---

# Introduction _(1.5 pages max)_

# Background and Related Work _(2 pages max)_

This project was conceived from research that Professor Kontogainnis had
completed with past students regarding the task of determining faults in
a large codebase using only past bug reports. Past students had experimented
with multiple algorithms for processing large amounts of bug reports in order
to come up with an index of files that are most likely to have a new bug
within them. 

The original system consisted of a collection of scripts written in Java,
Python and Shell. The scripts were fairly distributed and had very little
documentation. Most of the work was done in intermediate steps and did
not fit well together as a system because too much user intervention was
required between steps.

# Concepts, Terms, Definitions, Equations _(1 page max)_

### RSF
An RSF is a map of relationships betweens tokens within a codebase, where
a token is a keyword in the codebase such as a method. It is generated using
preprocessing scripts, and the result allows us to verify tokens inside of bug
reports.

### Bug Report
A database entry for each bug report used for the analysis. Each bug report
contains a String field containing what a user wrote inside their bug report.

### Token Expansion
Tokens extracted from the bug report are expanded to find other similar tokens.
Token expansion includes tokens that are referenced by the original token set.

### Clique

A collection of tokens that are referenced the most within the expanded set of tokens.

### Cluster

A group of relationships that are closely related to each other.

# Development Objectives _(0.75 page max)_

### Develop a complete system (O1)
Since they are so many individual parts to the system required to run the
system, we wanted to combine scripts and Java code into an easy to access
complete system. Considering there were still some Python scripts we did not
get access to by the end of the project, it would be very beneficial to have
a complete system that is able to handle new codebases and improve with new bug
reports.

### Be able to integrate with a GitHub based workflow (O2)
We saw a great opportunity to integrate this system into GitHub's system.
Initially, the system was set up to read reports from BugZilla, but we wanted
to add the ability to integrate the system with GitHib's issue tracker. This
would entail fetching new issues as they are created in a repo and processing
them, pushing results back to the issue page so the developers can get a head
start, and allowing users to authenticate using GitHub.

### Operate as a standalone service with a UI (O3)
The system initially was just run through a terminal, and because there aren't
too many options needed from the user, it would be beneficial to create
a system that can work independantly with an easy to use interface. This would
Work in a similar fashion to other CI tools, such as Travis. We would also plan
to give users the control to hook into any of their repositories.

# System Requirements _(2 pages max)_

### Section A : Data Processing

- **Feature 1:** Able to generate entity relationship rsf from codebase
  - FR 1: Pass code through cdif2rsf to generate rsf
  - FR 2: Clean up incorrect entity and relationships
  - FR 3: Store in accessible data storage for next step to use

- **Feature 2:**  Able to generate set of keywords from bug description
  - FR 1: Compare each token to codebase to find valid functions
  - FR 2: Expand initial token set by a factor of 3
  - FR 3: Use NLP to determine question context 

- **Feature 3:** Able to combine keywords and rsf into ranked outcomes
  - FR 1: Run LSI on each token and generate search space for each
  - FR 2: Expand the search space for each result in FR 1
  - FR 3: Find similarities between the initial token expansion and the final
    set of tokens
  - FR 4: Apply ranking equation from research paper to come up with final
    outcome

### Section B : Front-End User Interface

- **Feature 4:**  User is able to scan and mark a new repository for processing
  - FR 1: Scan user's Github repos using Github's API
  - FR 2: Allow the user to select ones they wish to run processing on
  - FR 3: Remember which ones the user selected by storing on backend

- **Feature 5:**  User is able to view the results of a new bug report's processing
  - FR 1: Monitor output from backend endpoints showing new results for user's repos
  - FR 2: When a new bug report is created, and the processing finishes, show
    the output of that processing on a separate page
  - FR 3: Allow the user to rerun processing on a specific bug report by
    sending a request to backend

- **Feature 6:**  User is able to login using their Github credentials
  - FR 1: On first usage redirect user to Github's App authentication page
  - FR 2: Ask backend to associate bug reports and repositories with this user
  - FR 3: Redirect user to main UI

### Section C : Back-End Runtime Processing

- **Feature 7:** Support front-end operations
  - FR 1: Allow registration using Github Auth
  - FR 2: Allow retrieval of processing results for each bug report
  - FR 3: Support re-running processing on a specific bug report
  - FR 4: Create a API where the UI can fetch everything from

- **Feature 8:** Manage the automation of Data Processing (F1, F2, and F3)
  - FR 1: Automate RSF generation when a new repository is linked
  - FR 2: Automate keyword generation when a new repository is linked
  - FR 3: Continuously improve and modify RSF and keywords as code/bugs change

- **Feature 9:** Handle processing and evaluation when a new bug report comes in
  - FR 1: Monitor marked repositories for each registered user and trigger when new issue is filed
  - FR 2: Run through automated ranking algorithm 
  - FR 3: Store result for later retrieval
  - FR 4: Be able to connect to a repository and fetch an issue when it is posted

- **Feature 10:** Combine each element of data processing into the backend runtime
  - FR 1: Combine entity generation into token generation
  - FR 2: Combine FR1 with RSF processing all into one unit
  - FR 3: Move all functionality to an exposed part of the API
  - FR 4: Create all endpoints for data processing functionality

# Development Strategy _(2 pages max)_

Since this project had a lot of the main functionality already implemented, we
did not have many choices over what development tools and languages to use. The
majority of the project was written in Java, with some separate Python scripts
used for data manipulation at some of the stages in the system. Including the
development tools previously mentioned, the following were also used in the
system: 

### Technologies

- Kotlin
- Python
- Java
- Javalin
- MongoDB
- Github Webhooks

### Tools

- Intellij Idea
- NeoVim
- Robo3T
- ngrok

## Datasets
- BugZilla reports

# Results _(10 pages max)_

### BugLocalization Project

- Restructured and cleaned up codebase
- Reduced very large codebase to 10 files 
- Documented and made more readable for easier integration 

### API

- Able to monitor a GitHub repo for events
- Detect new issues and add into a Mongo database
- Able to start and end deployments on Pull Requests

# Discussion _(1.5 pages max)_

### Threats to the validity of the results

Due to the large amount of bug reports and the possibility of having reports without enough details, the results are not guaranteed to find where the fault occurs. The ranking used in the system is useful in mitigating incorrect results, but does not gurantee that any of the results will be useful in determining the cause of fault in the software. A lot of other methods used to minimize the threats to validity were already implemented in the project, but it was mentioned that using different algorithms would allow us to compare the accuracy of different methods.

### Implications of the results

One of the original goals of this project was to implement another algorithm for determining the cause of fault to then use to compare the validity of the results for both algorithms. The validity of the results is important for a system like this because of how flexible it is for testing on software projects. The system would be language agnostic and allow the user to be able to accurately detect specific points of faults in software projects that use multiple languages. This is much more useful than traditional tools used for detecting issues in software and would be applicable to any project, where those that have large projects and/or use multiple languages would benefit the most. This system would save software engineers lots of time and effort wasted on debugging issues with software systems that don't provide enough information about where a fault in the program occurs.

### Limitations of the results

The main limitation to this project is the complexity of being able to detect a fault based on reports alone. When developing, users have many methods of getting feedback through logs and error detection that are not available to our system. The best way to remove this limitation would be to get more details from failure reports, but unfortunately there are not many alternatives that offer nearly as many reports as BugZilla.

# Conclusions _(1 page max)_

Unfortunately, for our project we had some communication problems for a large portion of the year. We ended up getting a late start to the project and had to re-purpose the project after the second milestone. Due to our late start and a couple missing scripts, we did not have access to all parts of the system needed to create a complete system and did not have enough time to create a standalone service with a UI. The implications of creating a complete system would mean that the computer running the system would have to be powerful enough to process all parts of the analysis within a reasonable amount of time in order to be of use to the programmer. Based on our testing with the components we had, we believe that this would be achievable if given access to the remaining parts of the program. We were able to refactor the code and greatly improve the structure and readability. The main method contained too much of the logic of the system, so modularizing the code and adding comments made it much easier to understand for others who will look at the code.

Completing O2 added the ability to connect to GitHub using their API and get issues from their tracker. Since the biggest change to the existing system is the report data used, the main structure of the system remains the same while allowing it to be used in another useful domain. Using this system in GitHub allows developers to easily discover faults in their applications. The system is set to be run whenever an issue was added by a user and would notify the repo owner.

# Future Work and Lessons Learnt _(1 page max)_

### Future work

- Develop software to process issues incrementally into the BugLocalization
- Integrate the BugLocalization project as part of the API and utilize its full
  power
- Make a web UI similar to Travis to display results 

### Lessons learnt

- Develop consistent communication plan with stakeholders
